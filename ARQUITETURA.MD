# ğŸ“– DocumentaÃ§Ã£o de DecisÃµes Arquiteturais

Este documento detalha as decisÃµes tÃ©cnicas, trade-offs e a arquitetura geral da soluÃ§Ã£o para o Nola God Level Coder Challenge, focada em resolver as dores da utilizadora "Maria".

## 1. Arquitetura da SoluÃ§Ã£o

A aplicaÃ§Ã£o foi construÃ­da com uma arquitetura Full Stack modular, separando o frontend (apresentaÃ§Ã£o) do backend (lÃ³gica de negÃ³cio e dados), comunicando via uma API RESTful.

### ğŸ–¥ï¸ Frontend (React)

* **Framework:** React + Vite
* **Justificativa:** O Vite foi escolhido pela sua performance de desenvolvimento (HMR rÃ¡pido). O React permite uma arquitetura baseada em componentes, ideal para criar uma UI complexa, mas reutilizÃ¡vel (ex: os componentes `AnalyticsDashboard` e `ClientesEmRisco`).
* **Bibliotecas-chave:**
    * `Recharts`: Para visualizaÃ§Ã£o de dados (grÃ¡ficos).
    * `react-datepicker`: Para os filtros de perÃ­odo de data.
    * `axios`: Para a comunicaÃ§Ã£o com o backend.

### âš¡ Backend (FastAPI + PostgreSQL + Redis)

* **Framework:** FastAPI (Python)
* **Justificativa:** O FastAPI foi escolhido pela sua altÃ­ssima performance assÃ­ncrona (ideal para operaÃ§Ãµes de I/O de banco de dados e cache) e pela sua integraÃ§Ã£o nativa com Pydantic, que valida automaticamente os filtros da API.
* **Banco de Dados:** PostgreSQL (Fornecido pelo desafio).
* **Cache:** Redis.
* **ExportaÃ§Ã£o:** Pandas (para geraÃ§Ã£o de CSV).

## 2. DecisÃµes TÃ©cnicas Chave (Justificativas)

A avaliaÃ§Ã£o foca em "como vocÃª pensa". Esta tabela resume os trade-offs:

| DecisÃ£o | Justificativa |
| :--- | :--- |
| **React + Recharts** | Simplicidade, reatividade e boa documentaÃ§Ã£o. Permite criar grÃ¡ficos interativos (como o `Brush` para zoom) de forma rÃ¡pida. |
| **FastAPI + PostgreSQL** | Alta performance. O Python tem uma integraÃ§Ã£o nativa e robusta com o ecossistema de dados (Pandas), o que facilitou a funcionalidade de "Exportar CSV". |
| **ImplementaÃ§Ã£o de Cache (Redis)** | **Requisito CrÃ­tico.** O desafio exigia "queries rÃ¡pidas". O Redis armazena os resultados das consultas da API, reduzindo a latÃªncia de >1s para <50ms em pedidos repetidos (Cache HITs). |
| **SQL DinÃ¢mico via Mapeamento** | Para evitar InjeÃ§Ã£o de SQL, o backend nÃ£o aceita SQL puro. Ele usa dicionÃ¡rios (METRICS_MAP, DIMENSIONS_MAP) para mapear parÃ¢metros seguros (ex: "ticket_medio") para trechos de SQL vÃ¡lidos ("AVG(v.total_amount)"). |
| **Arquitetura Modular (Abas)** | O frontend foi dividido em duas abas ("Dashboard" e "Clientes") para separar as preocupaÃ§Ãµes. O Dashboard foca em *agregaÃ§Ã£o*, e a AnÃ¡lise de Clientes foca em *segmentaÃ§Ã£o*, melhorando a UX. |

## 3. Performance e Escalabilidade

* **Cache (Redis):** Todas as consultas principais da API (`/api/analytics`, `/api/clientes-em-risco`, `/api/lojas`, etc.) sÃ£o cacheadas com um TTL (Time-to-Live) de 10 minutos. Isto garante que cliques repetidos nos filtros sejam instantÃ¢neos.
* **Queries Otimizadas:** As consultas ao PostgreSQL usam `GROUP BY` e `JOINs` eficientes.
* **Limite de Dados:** O endpoint `/api/analytics` (usado pelo grÃ¡fico) limita os resultados em 50 (`LIMIT 50`) para manter o frontend responsivo. O endpoint de exportaÃ§Ã£o (`/api/exportar-csv`) remove este limite para fornecer o relatÃ³rio completo.

## 4. Lacuna Identificada (Margem de Lucro)

A "dor" do utilizador sobre **"Quais produtos tÃªm menor margem...?"** nÃ£o foi implementada.

* **Justificativa:** A anÃ¡lise do schema de dados fornecido (`database-schema.sql`) revelou que, embora tenhamos o preÃ§o de venda (`base_price`), o **preÃ§o de custo** do produto nÃ£o estÃ¡ disponÃ­vel.
* **ConclusÃ£o:** Sem o custo, Ã© impossÃ­vel calcular a margem (`Venda - Custo`). A aplicaÃ§Ã£o estÃ¡ pronta para receber esta mÃ©trica assim que os dados de custo forem disponibilizados no banco.